
## zkProver

The task of creating the execution trace is performed by a component called the **zkExecutor**.
The zkExecutor takes as inputs the transactions of a batch, a ChainID, the root 
of a Merkle tree representing the previous state of the zkEVM in that chain and
the root of the new state after executing the transactions. 
Additionally, the zkExecutor gets values 
of the current state of the zkEVM to build the proof.

The zkExecutor is in fact an interpreter of an assembly language
called zkASM. 
The zkASM language is used to build a program called zkROM that 
when executed by the zkExecutor provides a suitable execution trace. The zkROM
is produced from the zkASM language by using the zkASM compiler, which is located in
the following repository:
[zkASM Compiler](https://github.com/0xPolygonHermez/zkasmcom). 
In the zkROM program (located in the following repository: 
[zkROM](https://github.com/0xPolygonHermez/zkevm-rom)),
each EVM opcode is implemented with a set of zkASM instructions. 
Each instruction utilizes a row of the execution trace matrix, 
also known as a "step" of the zkEVM. 

*Note*: A complete description of the zkASM language can be found in the 
following Section [Introduction to zkASM](../zkASM/introduction.md).

To see the zkASM compiler in action, it is possible to compile a .zkasm into
the corresponding .json file using the following commands inside the previous
repository:

```sh
$ node src/zkasm.js <input.zkasm> -o <output.json>
```

*Note*: Previously, it is important to install the node modules 
```sh
$ npm install
```
and build the parsers
```sh
$ npm run build
```

The .json file contains a field `program` which is an array of maps, 
each element representing a line of the .zkasm file. Among many fields, 
every element contain 

- `fileName`: Absolute path of the file containing the corresponding assembly row.
- `lineStr`: String representing the complete line of the corresponding .zkasm file.
- `line`: A line identifier. 
- Moreover, the corresponding setters, selectors, constants and instructions will be assigned accordingly. 
This point will be important for PIL validations, described below. 


The zkExecutor is part of the **zkProver**, which is the
core component of the Polygon zkEVM.

![](./figures/big-picture.png)

<div align="center"><b> Figure 1: Big picture of the Prover in the Polygon zkEVM. </b></div>


A the same time, there exists the need to check the correctness of each transition
between the rows of the execution trace generated by the zkExecutor. To do so, a new
Polynomial Identity Language **PIL** have been created. Recall
that having an execution trace is equivalent as having polynomials, each one 
representing each column. Therefore, using this language we will
be able to express several relations between consecutive rows of each of the columns 
computed by the zkExecutor in a polynomial-like way, allowing us to prove the 
correct execution via a STARK Recursion. The .pil files are compiled via a PIL compiler, 
which is located in the following repository: [PIL Compiler](https://github.com/0xPolygonHermez/pilcom).
The compiler, similarly as in the zkASM case, produces a .json which will be
interpreted by the STARK generator and, together with the execution trace (seen
as a set of polynomial evaluations) generated by the zkExecutor, will produce a proof. 

*Note*: A complete description of the PIL language can be found in the 
following Section [Introduction to PIL](../PIL/introduction.md).

To see the PIL compiler in action, it is possible to compile a .pil into
the corresponding .json file using the following commands inside the previous
repository:

```sh
$ node src/pil.js <input.pil> -o <output.pil.json>
```

*Note*: Previously, it is important to install the node modules 
```sh
$ npm install
```
and build the parsers
```sh
$ npm run build
```

First of all, the resulting .json file specifies, under the `references` key, 
all the polynomials that are references in the .pil file. The `references` key-value 
stores, in its keys, the name and the namespace associated to each polynomial in
the form `nameSpace.name`. Each value describes a property associated to each polynomial
such:

- `type`: specifies if a certain polynomial is commited, constant, calculated...

- `id`: unique *id* associated to each polynomial.

- `polDeg`: reflects the resulting polynomial degree.

- `isArray`: flag to control array-based polynomial definitions 
(see [PIL Components](../PIL/components.md) for more information). 

Among all the contents of the .json file, there is a key called `expressions` which 
is an array containing all the identities and operations among the corresponding
polynomials defined by the zkExecutor. The used values are input freely from the 
executor or taken from the .json compiled by the zkASM compiler. Moreover, there 
exists other keys which represent all inclusion, permutation and copy constrain
arguments. This .json will be finally used in the STARK proof generation, which 
will prove all the specified constrains. 

Another important key fields for debugging purposes are

- `nCommitements`: which specifies the total number of commited polynomials. 
 
- `nConstants`: which specifies the total number of constant polynomials 
referenced in the PIL file. 
